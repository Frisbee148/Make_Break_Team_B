{"ast":null,"code":"const colToIndex = col => {\n  let res = 0;\n  for (let i = 0; i < col.length; i++) {\n    res = res * 26 + (col.charCodeAt(i) - 64);\n  }\n  return res - 1;\n};\nconst parseAddress = addr => {\n  const m = addr.match(/^([A-Z]+)(\\d+)$/i);\n  if (!m) return null;\n  const col = m[1].toUpperCase();\n  const row = parseInt(m[2], 10) - 1;\n  return {\n    r: row,\n    c: colToIndex(col)\n  };\n};\nconst getCellValue = (cells, address) => {\n  const p = parseAddress(address);\n  if (!p) return null;\n  if (!cells[p.r] || cells[p.r][p.c] === undefined) return \"\";\n  const v = cells[p.r][p.c];\n  if (typeof v === \"string\" && v.startsWith(\"=\")) {\n    return evaluateFormula(cells, v);\n  }\n  return v === \"\" ? 0 : isNaN(Number(v)) ? v : Number(v);\n};\nconst expandRange = (cells, rangeStr) => {\n  const parts = rangeStr.split(\":\");\n  if (parts.length === 1) return [parts[0]];\n  const a = parseAddress(parts[0]);\n  const b = parseAddress(parts[1]);\n  if (!a || !b) return [];\n  const res = [];\n  for (let r = Math.min(a.r, b.r); r <= Math.max(a.r, b.r); r++) {\n    for (let c = Math.min(a.c, b.c); c <= Math.max(a.c, b.c); c++) {\n      const col = indexToCol(c);\n      res.push(`${col}${r + 1}`);\n    }\n  }\n  return res;\n};\nconst indexToCol = idx => {\n  let n = idx + 1;\n  let s = \"\";\n  while (n > 0) {\n    const r = (n - 1) % 26;\n    s = String.fromCharCode(65 + r) + s;\n    n = Math.floor((n - 1) / 26);\n  }\n  return s;\n};\nexport function evaluateFormula(cells, formula) {\n  if (!formula || formula[0] !== \"=\") return formula;\n  const body = formula.slice(1).trim();\n  const fn = body.split(\"(\")[0].toUpperCase();\n  const argsRaw = body.substring(body.indexOf(\"(\") + 1, body.lastIndexOf(\")\"));\n  const args = argsRaw.split(\",\").map(s => s.trim()).filter(Boolean);\n  if (fn === \"SUM\" || fn === \"AVERAGE\" || fn === \"COUNT\") {\n    let values = [];\n    args.forEach(a => {\n      if (a.includes(\":\")) {\n        const cellsList = expandRange(cells, a);\n        cellsList.forEach(addr => {\n          const val = getCellValue(cells, addr);\n          if (!isNaN(Number(val))) values.push(Number(val));\n        });\n      } else {\n        const val = getCellValue(cells, a);\n        if (!isNaN(Number(val))) values.push(Number(val));\n      }\n    });\n    if (fn === \"SUM\") return values.reduce((s, x) => s + x, 0);\n    if (fn === \"AVERAGE\") return values.length ? values.reduce((s, x) => s + x, 0) / values.length : 0;\n    if (fn === \"COUNT\") return values.length;\n  }\n  if (fn === \"IF\") {\n    var _args$, _args$2;\n    const cond = args[0];\n    const trueVal = (_args$ = args[1]) !== null && _args$ !== void 0 ? _args$ : \"\";\n    const falseVal = (_args$2 = args[2]) !== null && _args$2 !== void 0 ? _args$2 : \"\";\n    const condEval = cond.replace(/([A-Z]+\\d+)/g, m => JSON.stringify(getCellValue(cells, m)));\n    try {\n      if (eval(condEval)) return isFormulaLike(trueVal) ? evaluateFormula(cells, trueVal) : trueVal;else return isFormulaLike(falseVal) ? evaluateFormula(cells, falseVal) : falseVal;\n    } catch (e) {\n      return falseVal;\n    }\n  }\n  return body;\n}\nfunction isFormulaLike(s) {\n  return typeof s === \"string\" && s.startsWith(\"=\");\n}","map":{"version":3,"names":["colToIndex","col","res","i","length","charCodeAt","parseAddress","addr","m","match","toUpperCase","row","parseInt","r","c","getCellValue","cells","address","p","undefined","v","startsWith","evaluateFormula","isNaN","Number","expandRange","rangeStr","parts","split","a","b","Math","min","max","indexToCol","push","idx","n","s","String","fromCharCode","floor","formula","body","slice","trim","fn","argsRaw","substring","indexOf","lastIndexOf","args","map","filter","Boolean","values","forEach","includes","cellsList","val","reduce","x","_args$","_args$2","cond","trueVal","falseVal","condEval","replace","JSON","stringify","eval","isFormulaLike","e"],"sources":["C:/Users/amanm/OneDrive/Desktop/final/src/utils/formula.js"],"sourcesContent":["const colToIndex = col => {\n  let res = 0;\n  for (let i = 0; i < col.length; i++) {\n    res = res * 26 + (col.charCodeAt(i) - 64);\n  }\n  return res - 1;\n};\nconst parseAddress = addr => {\n  const m = addr.match(/^([A-Z]+)(\\d+)$/i);\n  if (!m) return null;\n  const col = m[1].toUpperCase();\n  const row = parseInt(m[2], 10) - 1;\n  return { r: row, c: colToIndex(col) };\n};\nconst getCellValue = (cells, address) => {\n  const p = parseAddress(address);\n  if (!p) return null;\n  if (!cells[p.r] || cells[p.r][p.c] === undefined) return \"\";\n  const v = cells[p.r][p.c];\n  if (typeof v === \"string\" && v.startsWith(\"=\")) {\n    return evaluateFormula(cells, v);\n  }\n  return v === \"\" ? 0 : isNaN(Number(v)) ? v : Number(v);\n};\nconst expandRange = (cells, rangeStr) => {\n  const parts = rangeStr.split(\":\");\n  if (parts.length === 1) return [parts[0]];\n  const a = parseAddress(parts[0]);\n  const b = parseAddress(parts[1]);\n  if (!a || !b) return [];\n  const res = [];\n  for (let r = Math.min(a.r, b.r); r <= Math.max(a.r, b.r); r++) {\n    for (let c = Math.min(a.c, b.c); c <= Math.max(a.c, b.c); c++) {\n      const col = indexToCol(c);\n      res.push(`${col}${r + 1}`);\n    }\n  }\n  return res;\n};\nconst indexToCol = idx => {\n  let n = idx + 1;\n  let s = \"\";\n  while (n > 0) {\n    const r = (n - 1) % 26;\n    s = String.fromCharCode(65 + r) + s;\n    n = Math.floor((n - 1) / 26);\n  }\n  return s;\n};\n\nexport function evaluateFormula(cells, formula) {\n  if (!formula || formula[0] !== \"=\") return formula;\n  const body = formula.slice(1).trim();\n  const fn = body.split(\"(\")[0].toUpperCase();\n  const argsRaw = body.substring(body.indexOf(\"(\") + 1, body.lastIndexOf(\")\"));\n  const args = argsRaw.split(\",\").map(s => s.trim()).filter(Boolean);\n\n  if (fn === \"SUM\" || fn === \"AVERAGE\" || fn === \"COUNT\") {\n    let values = [];\n    args.forEach(a => {\n      if (a.includes(\":\")) {\n        const cellsList = expandRange(cells, a);\n        cellsList.forEach(addr => {\n          const val = getCellValue(cells, addr);\n          if (!isNaN(Number(val))) values.push(Number(val));\n        });\n      } else {\n        const val = getCellValue(cells, a);\n        if (!isNaN(Number(val))) values.push(Number(val));\n      }\n    });\n    if (fn === \"SUM\") return values.reduce((s, x) => s + x, 0);\n    if (fn === \"AVERAGE\") return values.length ? values.reduce((s, x) => s + x, 0) / values.length : 0;\n    if (fn === \"COUNT\") return values.length;\n  }\n\n  if (fn === \"IF\") {\n    const cond = args[0];\n    const trueVal = args[1] ?? \"\";\n    const falseVal = args[2] ?? \"\";\n    const condEval = cond.replace(/([A-Z]+\\d+)/g, m => JSON.stringify(getCellValue(cells, m)));\n    try {\n      if (eval(condEval)) return isFormulaLike(trueVal) ? evaluateFormula(cells, trueVal) : trueVal;\n      else return isFormulaLike(falseVal) ? evaluateFormula(cells, falseVal) : falseVal;\n    } catch (e) {\n      return falseVal;\n    }\n  }\n\n  return body;\n}\n\nfunction isFormulaLike(s) {\n  return typeof s === \"string\" && s.startsWith(\"=\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}